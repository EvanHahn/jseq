// Generated by CoffeeScript 1.7.1
(function() {
  var BNP, TRM, TYPES, alert, assert, badge, debug, echo, help, info, log, praise, rpr, urge, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'jsEq';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  this.tests = require('./tests');

  BNP = require('coffeenode-bitsnpieces');


  /* TAINT should use customized fork */

  TYPES = require('coffeenode-types');


  /* implementations of deep equality tests: */

  assert = require('assert');

  this.implementations = {
    'NodeJS assert': {
      eq: function(a, b) {
        var error;
        try {
          assert.deepEqual(a, b);
        } catch (_error) {
          error = _error;
          return false;
        }
        return true;
      },
      ne: function(a, b) {
        var error;
        try {
          assert.notDeepEqual(a, b);
        } catch (_error) {
          error = _error;
          return false;
        }
        return true;
      }
    }
  };

  this.new_counter = function(name) {
    var R;
    R = {
      'name': name,
      'tests': 0,
      'fails': 0
    };
    return R;
  };

  this.main = function() {
    var count_type, counter, counters, errors_type, fail_count, implementation, implementation_count, implementation_name, length, pass_count, result, result_type, sub_count, sub_error, sub_errors, test, test_count, test_name, title, _i, _len, _ref, _ref1;
    implementation_count = 0;
    test_count = 0;
    fail_count = 0;
    counters = {};
    _ref = this.implementations;
    for (implementation_name in _ref) {
      implementation = _ref[implementation_name];
      implementation_count += 1;
      info(implementation_name);
      counter = counters[implementation_name] = this.new_counter(implementation_name);
      _ref1 = this.tests(implementation.eq, implementation.ne);
      for (test_name in _ref1) {
        test = _ref1[test_name];
        if (test_name[0] === '_') {
          continue;
        }
        test_count += 1;
        counter['tests'] += 1;
        title = "" + implementation_name + " / " + test_name;
        result = test.call(this.test);
        switch (result_type = TYPES.type_of(result)) {
          case 'boolean':
            if (result) {
              praise(title);
            } else {
              fail_count += 1;
              counter['fails'] += 1;
              warn(title);
            }
            break;
          case 'list':
            if ((length = result.length) !== 2) {
              throw new Error("" + title + ": expected list of length 2, got one with length " + length);
            }
            sub_count = result[0], sub_errors = result[1];
            if ((count_type = TYPES.type_of(sub_count)) !== 'number') {
              throw new Error("" + title + ": expected a number, got a " + count_type);
            }
            if (!(sub_count > 0 && sub_count === Math.floor(sub_count))) {
              throw new Error("" + title + ": expected an integer greater than zero, got " + sub_count);
            }
            if ((errors_type = TYPES.type_of(sub_errors)) !== 'list') {
              throw new Error("" + title + ": expected a list, got a " + errors_type);
            }
            test_count += sub_count;
            if (sub_errors.length === 0) {
              praise(title);
            } else {
              for (_i = 0, _len = sub_errors.length; _i < _len; _i++) {
                sub_error = sub_errors[_i];
                fail_count += 1;
                counter['fails'] += 1;
                warn("" + title + " / " + sub_error);
              }
            }
            break;
          default:
            throw new Error("" + title + ": expected a boolean or a list, got a " + result_type);
        }
      }
    }
    pass_count = test_count - fail_count;
    whisper('-------------------------------------------------------------');
    info("Tested " + implementation_count + " implementations.");
    info("Overall, " + test_count + " tests were run");
    praise("of which " + pass_count + " tests passed,");
    warn("and " + fail_count + " tests failed.");
    whisper('-------------------------------------------------------------');
    whisper(counters);
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
