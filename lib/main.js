// Generated by CoffeeScript 1.7.1
(function() {
  var BNP, TEXT, TRM, TYPES, Table, alert, assert, badge, debug, echo, help, info, log, praise, rpr, urge, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'jsEq';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  this.tests = require('./tests');

  BNP = require('coffeenode-bitsnpieces');

  TEXT = require('coffeenode-text');


  /* TAINT should use customized fork */

  TYPES = require('coffeenode-types');

  Table = require('cli-table');


  /* implementations of deep equality tests: */

  assert = require('assert');

  this.implementations = {
    "native ==": {
      eq: function(a, b) {
        return a == b;
      },
      ne: function(a, b) {
        return a != b;
      }
    },
    "native ===": {
      eq: function(a, b) {
        return a === b;
      },
      ne: function(a, b) {
        return a !== b;
      }
    },
    "NodeJS assert": {
      eq: function(a, b) {
        var error;
        try {
          assert.deepEqual(a, b);
        } catch (_error) {
          error = _error;
          return false;
        }
        return true;
      },
      ne: function(a, b) {
        var error;
        try {
          assert.notDeepEqual(a, b);
        } catch (_error) {
          error = _error;
          return false;
        }
        return true;
      }
    },
    "CoffeeNode Bits'N'Pieces": {
      eq: function(a, b) {
        return BNP.equals(a, b);
      },
      ne: function(a, b) {
        return !BNP.equals(a, b);
      }
    }
  };

  this.new_counter = function(name) {
    var R;
    R = {
      'name': name,
      'tests': 0,
      'fails': 0
    };
    return R;
  };

  this.main = function() {
    var count_type, counter, counters, errors_type, fail_count, fails, fails_percentage, idx, implementation, implementation_count, implementation_name, length, name, options, pass_count, passes, passes_percentage, result, result_type, sub_count, sub_error, sub_errors, table, test, test_count, test_name, tests, title, width, _i, _j, _len, _len1, _ref, _ref1;
    implementation_count = 0;
    test_count = 0;
    fail_count = 0;
    counters = [];
    _ref = this.implementations;
    for (implementation_name in _ref) {
      implementation = _ref[implementation_name];
      implementation_count += 1;
      info(implementation_name);
      counter = this.new_counter(implementation_name);
      counters.push(counter);
      _ref1 = this.tests(implementation.eq, implementation.ne);
      for (test_name in _ref1) {
        test = _ref1[test_name];
        if (test_name[0] === '_') {
          continue;
        }
        title = "" + implementation_name + " / " + test_name;
        result = test.call(this.test);
        switch (result_type = TYPES.type_of(result)) {
          case 'boolean':
            test_count += 1;
            counter['tests'] += 1;
            if (result) {
              praise(title);
            } else {
              fail_count += 1;
              counter['fails'] += 1;
              warn(title);
            }
            break;
          case 'list':
            if ((length = result.length) !== 2) {
              throw new Error("" + title + ": expected list of length 2, got one with length " + length);
            }
            sub_count = result[0], sub_errors = result[1];
            if ((count_type = TYPES.type_of(sub_count)) !== 'number') {
              throw new Error("" + title + ": expected a number, got a " + count_type);
            }
            if (!(sub_count > 0 && sub_count === Math.floor(sub_count))) {
              throw new Error("" + title + ": expected an integer greater than zero, got " + sub_count);
            }
            if ((errors_type = TYPES.type_of(sub_errors)) !== 'list') {
              throw new Error("" + title + ": expected a list, got a " + errors_type);
            }
            test_count += sub_count;
            counter['tests'] += sub_count;
            if (sub_errors.length === 0) {
              praise(title);
            } else {
              for (_i = 0, _len = sub_errors.length; _i < _len; _i++) {
                sub_error = sub_errors[_i];
                fail_count += 1;
                counter['fails'] += 1;
                warn("" + title + " / " + sub_error);
              }
            }
            break;
          default:
            throw new Error("" + title + ": expected a boolean or a list, got a " + result_type);
        }
      }
    }
    pass_count = test_count - fail_count;
    whisper('-------------------------------------------------------------');
    info("Tested " + implementation_count + " implementations.");
    info("Overall, " + test_count + " tests were run");
    praise("of which " + pass_count + " tests passed,");
    warn("and " + fail_count + " tests failed.");
    whisper('-------------------------------------------------------------');
    counters.sort(function(a, b) {
      if (a['fails'] > b['fails']) {
        return +1;
      }
      if (a['fails'] < b['fails']) {
        return -1;
      }
      return 0;
    });
    options = {
      head: ['rank', 'implementation', 'tests', 'passes', '%', 'fails', '%'],
      chars: {
        'mid': '',
        'left-mid': '',
        'mid-mid': '',
        'right-mid': ''
      }
    };
    table = new Table(options);
    width = 8;
    for (idx = _j = 0, _len1 = counters.length; _j < _len1; idx = ++_j) {
      counter = counters[idx];
      name = counter.name, tests = counter.tests, fails = counter.fails;
      passes = tests - fails;
      passes_percentage = "" + ((passes / tests * 100).toFixed(1)) + " %";
      fails_percentage = "" + ((fails / tests * 100).toFixed(1)) + " %";
      table.push([TRM.grey(idx + 1), TRM.gold(name), TRM.blue(tests), TRM.green(TEXT.flush_right(passes, width)), TRM.green(TEXT.flush_right(passes_percentage, width)), TRM.red(TEXT.flush_right(fails, width)), TRM.red(TEXT.flush_right(fails_percentage, width))]);
    }
    console.log(table.toString());
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
