// Generated by CoffeeScript 1.7.1
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'jsEq/tests';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  module.exports = function(eq, ne) {
    var R;
    R = {};

    /* 1. simple tests */

    /* 1.1. positive */
    R["NaN equals NaN"] = function() {
      return eq(NaN, NaN);
    };
    R["finite integer n equals n"] = function() {
      return eq(1234, 1234);
    };
    R["emtpy array equals empty array"] = function() {
      return eq([], []);
    };
    R["emtpy object equals empty object"] = function() {
      return eq({}, {});
    };

    /* 1.2. negative */
    R["object doesn't equal array"] = function() {
      return ne({}, []);
    };
    R["object in a list doesn't equal array in array"] = function() {
      return ne([{}], [[]]);
    };
    R["integer n doesn't equal rpr n"] = function() {
      return ne(1234, '1234');
    };
    R["empty array doesn't equal false"] = function() {
      return ne([], false);
    };
    R["array with an integer doesnt equal one with rpr n"] = function() {
      return ne([3], ['3']);
    };

    /* 2. complex tests */
    R["circular arrays with same layout and same values are equal"] = function() {
      var d, e;
      d = [1, 2, 3];
      d.push(d);
      e = [1, 2, 3];
      e.push(d);
      return eq(d, e);
    };

    /* joshwilsdon's test (https://github.com/joyent/node/issues/7161) */
    R["joshwilsdon"] = function() {
      var d1, d2, errors, idx1, idx2, v1, v2, _i, _j, _len, _ref;
      d1 = [
        NaN, void 0, null, true, false, Infinity, 0, 1, "a", "b", {
          a: 1
        }, {
          a: "a"
        }, [
          {
            a: 1
          }
        ], [
          {
            a: true
          }
        ], {
          a: 1,
          b: 2
        }, [1, 2], [1, 2, 3], {
          a: "1"
        }, {
          a: "1",
          b: "2"
        }
      ];
      d2 = [
        NaN, void 0, null, true, false, Infinity, 0, 1, "a", "b", {
          a: 1
        }, {
          a: "a"
        }, [
          {
            a: 1
          }
        ], [
          {
            a: true
          }
        ], {
          a: 1,
          b: 2
        }, [1, 2], [1, 2, 3], {
          a: "1"
        }, {
          a: "1",
          b: "2"
        }
      ];
      errors = [];
      for (idx1 = _i = 0, _len = d1.length; _i < _len; idx1 = ++_i) {
        v1 = d1[idx1];
        for (idx2 = _j = idx1, _ref = d2.length; idx1 <= _ref ? _j < _ref : _j > _ref; idx2 = idx1 <= _ref ? ++_j : --_j) {
          v2 = d2[idx2];
          if (idx1 === idx2) {
            if (!eq(v1, v2)) {
              errors.push("eq " + (rpr(v1)) + ", " + (rpr(v2)));
            }
          } else {
            if (!ne(v1, v2)) {
              errors.push("ne " + (rpr(v1)) + ", " + (rpr(v2)));
            }
          }
        }
      }
      return [d1.length, errors];
    };
    return R;
  };

}).call(this);
