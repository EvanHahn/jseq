// Generated by CoffeeScript 1.7.1
(function() {
  var TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'jsEq/tests';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  module.exports = function(eq, ne) {
    var R;
    R = {};

    /* 1. simple tests */

    /* 1.1. positive */
    R["NaN eqs NaN"] = function() {
      return eq(NaN, NaN);
    };
    R["finite integer n eqs n"] = function() {
      return eq(1234, 1234);
    };
    R["emtpy list eqs empty list"] = function() {
      return eq([], []);
    };
    R["emtpy pod eqs empty pod"] = function() {
      return eq({}, {});
    };
    R["number eqs number of same value"] = function() {
      return eq(123.45678, 123.45678);
    };
    R["number pod eqs primitive number of same value"] = function() {
      return eq(5, new Number(5));
    };
    R["string pod eqs primitive string of same value"] = function() {
      return eq('helo', new String('helo'));
    };
    R["regex lit's w same pattern, flags are eq"] = function() {
      return eq(/^abc[a-zA-Z]/, /^abc[a-zA-Z]/);
    };
    R["pods w same properties are eq"] = function() {
      return eq({
        a: 'b',
        c: 'd'
      }, {
        a: 'b',
        c: 'd'
      });
    };
    R["pods that only differ wrt prop ord are eq"] = function() {
      return eq({
        a: 'b',
        c: 'd'
      }, {
        c: 'd',
        a: 'b'
      });
    };

    /* 1.2. negative */
    R["pod doesn't eq list"] = function() {
      return ne({}, []);
    };
    R["pod in a list doesn't eq list in list"] = function() {
      return ne([{}], [[]]);
    };
    R["integer n doesn't eq rpr n"] = function() {
      return ne(1234, '1234');
    };
    R["empty list doesn't eq false"] = function() {
      return ne([], false);
    };
    R["list w an integer doesn't eq one w rpr n"] = function() {
      return ne([3], ['3']);
    };
    R["regex lit's w diff. patterns, same flags aren't eq"] = function() {
      return ne(/^abc[a-zA-Z]/, /^abc[a-zA-Z]x/);
    };
    R["regex lit's w same patterns, diff. flags aren't eq"] = function() {
      return ne(/^abc[a-zA-Z]/, /^abc[a-zA-Z]/i);
    };
    R["+0 should ne -0"] = function() {
      return ne(+0, -0);
    };
    R["pods that only differ wrt prop ord aren't eq"] = function() {
      return ne({
        a: 'b',
        c: 'd'
      }, {
        c: 'd',
        a: 'b'
      });
    };

    /* 2. complex tests */
    R["list w named member eqs other list w same member"] = function() {
      var d, e;
      d = ['foo', null, 3];
      d['extra'] = 42;
      e = ['foo', null, 3];
      e['extra'] = 42;
      return eq(d, e);
    };
    R["list w named member doesn't eq list w same member, other value"] = function() {
      var d, e;
      d = ['foo', null, 3];
      d['extra'] = 42;
      e = ['foo', null, 3];
      e['extra'] = 108;
      return ne(d, e);
    };
    R["date eqs other date pointing to same time"] = function() {
      var d, e;
      d = new Date("1995-12-17T03:24:00");
      e = new Date("1995-12-17T03:24:00");
      return eq(d, e);
    };
    R["date does not eq other date pointing to other time"] = function() {
      var d, e;
      d = new Date("1995-12-17T03:24:00");
      e = new Date("1995-12-17T03:24:01");
      return ne(d, e);
    };
    R["circular arrays w same layout and same values are eq (1)"] = function() {
      var d, e;
      d = [1, 2, 3];
      d.push(d);
      e = [1, 2, 3];
      e.push(d);
      return eq(d, e);
    };
    R["circular arrays w same layout and same values are eq (2)"] = function() {
      var d, e;
      d = [1, 2, 3];
      d.push(d);
      e = [1, 2, 3];
      e.push(e);
      return eq(d, e);
    };

    /* joshwilsdon's test (https://github.com/joyent/node/issues/7161) */
    R["joshwilsdon"] = function() {
      var count, d1, d2, errors, idx1, idx2, v1, v2, _i, _j, _len, _ref;
      d1 = [
        NaN, void 0, null, true, false, Infinity, 0, 1, "a", "b", {
          a: 1
        }, {
          a: "a"
        }, [
          {
            a: 1
          }
        ], [
          {
            a: true
          }
        ], {
          a: 1,
          b: 2
        }, [1, 2], [1, 2, 3], {
          a: "1"
        }, {
          a: "1",
          b: "2"
        }
      ];
      d2 = [
        NaN, void 0, null, true, false, Infinity, 0, 1, "a", "b", {
          a: 1
        }, {
          a: "a"
        }, [
          {
            a: 1
          }
        ], [
          {
            a: true
          }
        ], {
          a: 1,
          b: 2
        }, [1, 2], [1, 2, 3], {
          a: "1"
        }, {
          a: "1",
          b: "2"
        }
      ];
      errors = [];
      count = 0;
      for (idx1 = _i = 0, _len = d1.length; _i < _len; idx1 = ++_i) {
        v1 = d1[idx1];
        for (idx2 = _j = idx1, _ref = d2.length; idx1 <= _ref ? _j < _ref : _j > _ref; idx2 = idx1 <= _ref ? ++_j : --_j) {
          count += 1;
          v2 = d2[idx2];
          if (idx1 === idx2) {
            if (!eq(v1, v2)) {
              errors.push("eq " + (rpr(v1)) + ", " + (rpr(v2)));
            }
          } else {
            if (!ne(v1, v2)) {
              errors.push("ne " + (rpr(v1)) + ", " + (rpr(v2)));
            }
          }
        }
      }
      return [count, errors];
    };
    return R;
  };

}).call(this);
